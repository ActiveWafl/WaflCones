<?php
namespace WaflCones\DataModel;

use \DblEj\Data\Field;

/**
 * Sale
 * Represents a row in the database table Sales
 */
abstract class Sale
extends \DblEj\Data\PersistableModel
{

    /**
     * SaleId
     *
     * Data Storage (Wafl\Extensions\Storage\Mysql): 
     *        Primary Key
     *        Type: DATA_TYPE_INT unsigned
     *        Default: null
     *
     * @var integer
     */
    protected $_saleId;

    /**
     * SaleDate
     *
     * Data Storage (Wafl\Extensions\Storage\Mysql): 
     *        Type: DATA_TYPE_INT unsigned
     *        Default: null
     *
     * @var integer
     */
    protected $_saleDate;

    /**
     * Price
     *
     * Data Storage (Wafl\Extensions\Storage\Mysql): 
     *        Type: DATA_TYPE_DECIMAL
     *        Default: null
     *
     * @var float
     */
    protected $_price;

    /**
     * EmployeeId
     *
     * Data Storage (Wafl\Extensions\Storage\Mysql): 
     *        Type: DATA_TYPE_INT unsigned
     *        Default: null
     *
     * @var integer
     */
    protected $_employeeId;
    /**
     * Get_FieldDataTypes
     *
     * Get an array of this model's fields and their data types
     *
     */
    public static function GetFieldDataTypes()
    {
        $fieldTypes = array();
                $fieldTypes["SaleId"] = Field::DATA_TYPE_INT;
        $fieldTypes["SaleDate"] = Field::DATA_TYPE_INT;
        $fieldTypes["Price"] = Field::DATA_TYPE_DECIMAL;
        $fieldTypes["EmployeeId"] = Field::DATA_TYPE_INT;
        return $fieldTypes;
    }

    /**
     * Search
     *
     * Search an index for the given criteria and return matching Sales.
     * An "index" in this context refers to an implementor of IIndex and is generated by an IIndexer (such as the Apache Solr Indexer Extension).
     *
     * @param string $searchFieldName The name of the INDEX FIELD (not necessarily the same as the model or table's field) to search on.
     * @param string $searchValue The indexed value to search for.
     * @param \DblEj\Data\IndexSort[] $sorts How to sort the results.
     * @param int $maxResults The maximum number of results to return.
     * @param int $startOffset The start offset of results to return.
     * @param string $resultKeyField The name of the indexes key field which will be used to lookup the ctual data in the data storage.
     * @param \DblEj\Data\IIndex $searchIndex Which index to seach.  If not provided, the default search index will be used.
     * @return \WaflCones\FunctionalModel\Sale[]
     * @throws \Exception
     */
    public static function Search($searchFieldName, $searchValue, $sorts = null, $maxResults = 100, $startOffset = 0, $resultKeyField = null, \DblEj\Data\IIndex $searchIndex = null)
    {
        self::Initialize();
        return self::_search($searchFieldName, $searchValue, $sorts, $resultKeyField, $maxResults, $startOffset, $searchIndex);
    }

    /**
     * Filter
     *
     * Get the Sale's from the Storage Engine that matches the given filter and other criteria.
     *
     * @param string $filter optional The filter to filter by.  If no filter is passed in, then all results are returned.
     * @param string $orderByFieldName optional The name of the field to order the Sale's by
     * @param int $maxRecordCount optional The maximum number of Sale's to return
     * @param string $groupingField optional The name of the field to group on.
     * @param array $joinObjects optional The tables and fields to join as part of the search criteria (note: joined columns are not returned as properties of the data model).
     * @param int $startOffset optional
     * @param string $arrayKeyField optional
     * @param boolean $useCachedIfAvailable optional
     * If true, the filter will return the result from the last call who's result was not from the cache that was made to this method with identical filter and related settings.
     * @return \WaflCones\FunctionalModel\Sale[] an array of the matching Sales
     * @throws DataModelException
     * @throws DataException
     */
    public static function Filter($filter = null, $orderByFieldName = null, $maxRecordCount = null, $groupingField = null,
    $joinObjects = null, $startOffset = 0, $arrayKeyField = null, $useCachedIfAvailable = true)
    {
        self::Initialize();
        return self::_filter($filter, $orderByFieldName, $maxRecordCount, $groupingField, $joinObjects, $startOffset, $arrayKeyField, $useCachedIfAvailable);
    }

    /**
     * FilterFirst
     *
     * Get the Sale's from the Storage Engine that matches the given filter and other criteria.
     *
     * @param string $filter optional The filter to filter by.  If no filter is passed in, then all results are returned.
     * @param string $orderByFieldName optional The name of the field to order the result objects by.
     * @param string $groupingField optional The name of the field to group on.
     * @param array $joinObjects optional
     * An array of items to inner-join on the filterable object as an added filter constraint.
     * The array should be associative where the key is the name of the item to join on
     * and the value is the name of a field that is <b>mutual</b> between the filterable item and the join item.
     * If there is not a mutual field between the items, then the value should be null.
     * In that case, you will need to add an equality condition to the
     * <i>$filter</i> for the fields you wish to join on.
     * @param boolean $useCachedIfAvailable optional
     * If true, the filter will return the result from the last call who's result was not from the cache that was made to this method with identical filter and related settings.
     *
     * @return null|\WaflCones\FunctionalModel\Sale the first matching Sales
     * @throws DataModelException
     */
    public static function FilterFirst($filter = null, $orderByFieldName = null, $groupingField = null, $joinObjects = null, $useCachedIfAvailable = true)
    {
        self::Initialize();
        return self::_filterFirst($filter, $orderByFieldName, $groupingField, $joinObjects, $useCachedIfAvailable);
    }


    /**
     * Get the current SaleId for this Sale.
     *
     * @return integer The SaleId
     */
    public function Get_SaleId()
    {
        return $this->_saleId;
    }

    /**
     * Set the SaleId for this Sale
     *
     * @return \WaflCones\FunctionalModel\Sale This instance is returned back to the caller to facilitate chained method calls
     */
    public function Set_SaleId($saleId)
    {
        if ($this->_saleId !== $saleId)
        {
        
            if (!$this->CanCurrentUserSetProperty("SaleId"))
            {
                throw new \Exception("Current user does not have permission to set model property");
            }

            $this->_saleId = $saleId;
            $this->ModelChanged("SaleId");
        }
        return $this;
    }


    /**
     * Get the current SaleDate for this Sale.
     *
     * @return integer The SaleDate
     */
    public function Get_SaleDate()
    {
        return $this->_saleDate;
    }

    /**
     * Set the SaleDate for this Sale
     *
     * @return \WaflCones\FunctionalModel\Sale This instance is returned back to the caller to facilitate chained method calls
     */
    public function Set_SaleDate($saleDate)
    {
        if ($this->_saleDate !== $saleDate)
        {
        
            if (!$this->CanCurrentUserSetProperty("SaleDate"))
            {
                throw new \Exception("Current user does not have permission to set model property");
            }

            $this->_saleDate = $saleDate;
            $this->ModelChanged("SaleDate");
        }
        return $this;
    }


    /**
     * Get the current Price for this Sale.
     *
     * @return float The Price
     */
    public function Get_Price()
    {
        return $this->_price;
    }

    /**
     * Set the Price for this Sale
     *
     * @return \WaflCones\FunctionalModel\Sale This instance is returned back to the caller to facilitate chained method calls
     */
    public function Set_Price($price)
    {
        if ($this->_price !== $price)
        {
        
            if (!$this->CanCurrentUserSetProperty("Price"))
            {
                throw new \Exception("Current user does not have permission to set model property");
            }

            $this->_price = $price;
            $this->ModelChanged("Price");
        }
        return $this;
    }


    /**
     * Get the current EmployeeId for this Sale.
     *
     * @return integer The EmployeeId
     */
    public function Get_EmployeeId()
    {
        return $this->_employeeId;
    }

    /**
     * Set the EmployeeId for this Sale
     *
     * @return \WaflCones\FunctionalModel\Sale This instance is returned back to the caller to facilitate chained method calls
     */
    public function Set_EmployeeId($employeeId)
    {
        if ($this->_employeeId !== $employeeId)
        {
        
            if (!$this->CanCurrentUserSetProperty("EmployeeId"))
            {
                throw new \Exception("Current user does not have permission to set model property");
            }

            $this->_employeeId = $employeeId;
            $this->ModelChanged("EmployeeId");
        }
        return $this;
    }

                    
    private $_employee = null;

    /**
    * Get the related Employee
    *
    * @return \WaflCones\FunctionalModel\Employee The Employee
    */
    public function GetEmployee($reloadFromSource = false)
    {
        if (!$this->_employee || $reloadFromSource || $this->IsFieldDirty("EmployeeId"))
        {
            $this->_employee = \WaflCones\FunctionalModel\Employee::FilterFirst("EmployeeId = '".$this->Get_EmployeeId()."'");
        }
        return $this->_employee;
    }

    /**
     * Get Flavors related to this Sale (cross-ref: SaleItems) (1b)
     *
     * @param $sortBy The name of the field to sort on.
     * @param $filter Additional query filter to apply.
     * @return \WaflCones\FunctionalModel\Flavor[]
     */
    public function GetFlavorsCrossReferencedBySaleItems($sortBy = null, $filter = null)
    {
        $clause = "SaleItems.SaleId = '".$this->Get_SaleId()."'";
        if ($filter)
        {
            $clause = "$clause and ($filter)";
        }

        return \WaflCones\FunctionalModel\Flavor::Filter($clause, $sortBy, null, null, array("SaleItems"=>"FlavorId"));
    }

    /**
     * Get the related SaleItems for this Sale
     *
     * @param $sortBy The name of the field to sort on.
     * @param $filter Additional query filter to apply.
     * @param $maxRecordCount The maximum number of records to return.
     * @param $startOffset The record offset to start with.
     * @param $useCachedIfAvailable Should cached in-memory results be returned instead of re-querying the data source?
     * @return \WaflCones\FunctionalModel\SaleItem[]
     */
    public function GetSaleItems($sortBy = null, $filter = null, $maxRecordCount = null, $startOffset = 0, $useCachedIfAvailable = true)
    {
        if ($this->Get_SaleId())
        {
            $clause = "SaleId = '".$this->Get_SaleId()."'";
            if ($filter)
            {
                $clause = "$clause and ($filter)";
            }
            
            return \WaflCones\FunctionalModel\SaleItem::Filter($clause, $sortBy, $maxRecordCount, null, null, $startOffset, null, $useCachedIfAvailable);
        } else {
            return array();
        }
    }

    /**
    * Gets the name of the field that stores a unique key identifying each instance.
    * This is often the primary key in your database table.
    *
    * @return string
    */
    public static function Get_KeyFieldName()
    {
        return "SaleId";
    }

    /**
    * Whether or not the values in the KeyField are generated automatically (like a database auto-increment) or if they generated manually.
    *
    * @return boolean TRUE if the values are generated automatically by the engine, otherwise FALSE
    */
    public static function Get_KeyIsAutoGenerated()
    {
        return true;
    }

    /**
    * A Storage Engine specific string that tells the Storage Engine where this Model is to be stored.
    * This is typically the name of a database table.
    *
    * @return string
    */
    public static function Get_Destination()
    {
        return "Sales";
    }

    /**
    * An arbitrary logical grouping for objects that can be stored in a storage engine.
    * If you have a Storage Engine set up with the same Storage Group, then ActiveWafl will use that storage engine when retrieving and persisting models of this type.
    * @return string
    */
    public static function Get_StorageGroup()
    {
        return "WaflCones";
    }
}